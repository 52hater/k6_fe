//자바스크립트 데이터 타입
//기본 타입 프리미티브타입 primitive type에서 문자열만 특수한 케이스
//const 아니면 let // const는 안바뀜 let은 바뀔 수 있다
let n1 = 10;//정수
let n2 = 10.5;//실수
let s1 = "안녕하세요."//문자열 //따옴표안에 묶인게 한개 > 사실따지고보면 .까지쳐서 많지 > 캐릭터의 배열느낌
//근데 여튼 한개로 인식함 > 한개씩 읽는거(순회)를 하고싶으면 s1의 몇번째(인덱스) > s1[0],s1[2]...>이럴때 반복문 써야지
//문자열 늘어나면 콘솔추가해야되잖 > 반복문은 문자열의 개수만큼 도니까 > for in의 개념 > i를 돌리고 자시고 그냥 배열에서 한개씩 끄집어오면 되겠네
//in 뒤에 컬렉션타입?의 객체만 오면 알아서 한개씩 뺴면서 ㅇㅇ
//배열의 키는 인덱스

console.log("정수 : ", n1);
console.log("실수 : ", n2);
console.log("문자열 : ", s1);//문자열:배열과 비슷

//문자열 순회
//파이썬의 for in 이 자바스크립트의 for of
//자바스크립트의 for in은 순서대로 01234 인덱스를 가지고 옴 arr[0]=안
//for of 는 c는 요소값 그대로 가지고 옴
for(let i in s1) {//in을쓰면 키값이 나와(문자열의 키는 인덱스) 인으로 돌면 키 값
    console.log("문자열 : ", s1[i]);
}
for(let c of s1) {//오브로 돌면 값을 가지고 옴//두 개 차이점 알아야
    console.log("문자열 : ", c);
}
console.log("문자열 : ", s1[1]);

//배열
let arr = ['😊', 1, '😂😂', 2, '😁😁😁', 3, ]//js의 배열은 파이썬의 리스트와 흡사//오브젝트가 파이썬의 딕셔너리라고 보면 됨//순서로할거냐 키로할거냐
//파이썬은 리스트와 튜플과 딕셔너리가 가장 중요, 반복문도 중요//튜플은 수정삭제가 안되는것빼고는 리스트와 같음//리턴타입을 잘 봐야 한대.
//테일링쉼표 사용가능(윗줄 마지막 쉼표)/기호주의///
console.log("배열 : ", arr);
console.log("배열의 요소 접근 : ", arr[1]);

//배열의 순회
console.log("배열 for in")
for(let i in arr) {//in을쓰면 키값이 나와(문자열의 키는 인덱스) 인으로 돌면 키 값
    console.log("배열 : ", arr[i]);
}
for(let c of arr) {//오브로 돌면 값을 가지고 옴//두 개 차이점 알아야
    console.log("배열 : ", c);
}//인은 인덱스(키) 오브는 요소(값)


//배열에는 map함수가 있음 (****)
console.log("배열의 map함수")//for of 하고 똑같음 그런데 배열을쓸때는 맵을 쓰면 됨(한개씩 접근)
let arr2 = arr.map((v, i) => {//두개를 줄 수 있다//값이 먼저 나오고 인덱스가 나옴 //배열 arr이 가지고 있는 메소드, 인수로 콜백함수를 가짐
    console.log("map: v", v);
    console.log("map: i", i);//값과 인덱스를 받으려면 map으로 받으면 됨
    return v + "❤";//붙여서 맵함수의 결과를 리턴하는데 결과를 받아서 컨스트 arr2를 만들 수 있음//함수니까 리턴할수있지
    //리턴된걸 모아야지 > const arr2로//배열의 개수만큼 리턴//arr2는 arr과 개수가 같음
    //arr을 돌면서 리턴을 한거를 배열에다가 모은거니까
    //그래서 맵은 원래배열의 개수와 동일한 개수가 나옴
}); //내부에 콜백함수

console.log("arr2 =" + arr2);
//arr.map(() => {});//이렇게 인수로 콜백함수를 가짐, 파라미터가 들어와야하는데
//arr.map((v) => {//v는 아무거나 쓴 것
    
//    return v //리턴

//
console.log("배열 맵함수 : 콜백");
//콜백의 인수가 1개인 경우는 () 생략가능
//콜백의 body에 실행문이 없고 return문만 있으면 {}와 return 생략 가능
arr2 = arr.map( v => v+"❤");//앞으로 이런 코드를 많이 쓰게 될 것
console.log("arr2 = ", arr2)


//오브젝트
let obj = {'😊' : 1, '😂😂' : 2, '😁😁😁' : 3,};//맨뒤에 의미없고 오류없는 쉼표 : 테일링 쉼표 tailing 쉼표 사용가능/기호주의//키/밸류(스마일/1)
console.log("오브젝트 : ", obj);
console.log("오브젝트 요소 접근 : ", obj['😊']);

//오브젝트 순회 > 키하고 값을 쌍으로 갖고와야함
console.log("오브젝트 for in");
for(let i in obj) {//in을쓰면 키값이 나와(문자열의 키는 인덱스) 인으로 돌면 키 값
    console.log("오브젝트 : ", obj[i]);
}
console.log("오브젝트 for of");
for(let c of Object.entries(obj)) {//앞에것이 키 뒤엣것이 값//엔트리즈로 풀어서 써야함 of를 쓰기 힘듦//엔트리즈하니까 배열이 됨/키하고 값을 갖고옴/맵에서는 값과 키 순서
    console.log("오브젝트 : ", c);//여기에 변수명c는 아무거나 쓰면 됨
}
for(let c of Object.entries(obj)) {
    console.log("오브젝트 : ", c);
    console.log("오브젝트 : ", c[0]);
    console.log("오브젝트 : ", c[1]);
}


for(let [k, v] of Object.entries(obj)) {
    console.log("오브젝트 : ", k);
    console.log("오브젝트 : ", v);//구조분할 > 나눠서 받고싶어 /배열에 키하고 값이 출력이 됐잖아, 첫번째거 두번쨰거 변수를 각각 주는, k에 키가 들어오고 v에 값이 들어오고
}

//오브젝트는 맵을 못씀, 이런식으로는 할 수 있지
console.log("오브젝트 키배열 :", Object.keys(obj));//키배열이 생김, 맵, 필터 쓸 수 있음
let arr3 = Object.keys(obj).map(k => k + obj[k]);
console.log("arr3 =", arr3)
//오브젝트에 접근할때는 대괄호

//문자열 배열 오브젝트는 여러개가 한 묶음, 한개씩 한개씩 접근할 수 있어야 됨
//자바스크립트의 오브젝트는 파이썬의 딕셔너리라고 보면 됨>딕셔너리.items 를쓰면 for in을 쓰면 키/값 쌍으로 갖고옴(파이썬)

//딕셔너리는 키/값 구분이 되는구나 하고 이해

//로또 언제끝날지모른다와일문, 숫자겹치면안돼>하나씩 푸쉬, 문자열은 자르는게 중요한데(슬라이싱)js에선 서브스트링이나 슬라이스 찾아서
//슬라이스는 마이너스인덱스 쓸 수 있지
//let arr[];
//pop은 빼는거 딜리트
//언시프트 시프트 앞쪽에서 넣고뺴고/많이안씀
//배열의복사를 맵함수로 했고 푸시도썼다

//전개연산자
let arr22 = [...arr];
console.log("전개연산자 : ")